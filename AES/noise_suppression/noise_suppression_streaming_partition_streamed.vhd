-- -------------------------------------------------------------
-- 
-- File Name: C:\Users\wickh\Documents\NIH\simulink_models\models\noise_suppression\hdlsrc\noise_suppression\noise_suppression_streaming_partition_streamed.vhd
-- 
-- Generated by MATLAB 9.7 and HDL Coder 3.15
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: noise_suppression_streaming_partition_streamed
-- Source Path: 
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.noise_suppression_dataplane_pkg.ALL;

ENTITY noise_suppression_streaming_partition_streamed IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        in0                               :   IN    vector_of_std_logic_vector24(0 TO 1);  -- sfix24_En23 [2]
        in1                               :   IN    vector_of_std_logic_vector24(0 TO 1);  -- sfix24_En23 [2]
        in2                               :   IN    std_logic_vector(15 DOWNTO 0);  -- ufix16_En15
        in3                               :   IN    vector_of_std_logic_vector50(0 TO 1);  -- sfix50_En47 [2]
        globalSchedule                    :   IN    std_logic;
        out0                              :   OUT   vector_of_std_logic_vector25(0 TO 1);  -- sfix25_En23 [2]
        out1                              :   OUT   vector_of_std_logic_vector24(0 TO 1);  -- sfix24_En20 [2]
        out2                              :   OUT   vector_of_std_logic_vector27(0 TO 1)  -- sfix27_En24 [2]
        );
END noise_suppression_streaming_partition_streamed;


ARCHITECTURE rtl OF noise_suppression_streaming_partition_streamed IS

  ATTRIBUTE multstyle : string;

  ATTRIBUTE multstyle OF rtl : ARCHITECTURE IS "dsp";

  -- Signals
  SIGNAL enb_gated                        : std_logic;
  SIGNAL in0_signed                       : vector_of_std_logic_vector24(0 TO 1);  -- ufix24 [2]
  SIGNAL in1_signed                       : vector_of_std_logic_vector24(0 TO 1);  -- ufix24 [2]
  SIGNAL in3_signed                       : vector_of_std_logic_vector50(0 TO 1);  -- ufix50 [2]
  SIGNAL ctr_1_sig                        : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL ratechange_splitcomp_out0        : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL ratechange_splitcomp_out1        : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Sink_Data_unbuffer               : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL ratechange_splitcomp_out0_1      : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL ratechange_splitcomp_out1_1      : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL mean_unbuffer                    : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Add2_sub_cast                    : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL Add2_sub_cast_1                  : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL Add2_out1                        : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL ctr_1_sig_eq_0_cmpOut            : std_logic;
  SIGNAL ctr0                             : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL Add2_out1_demux0                 : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL yreg_0                           : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL ctr_1_sig_eq_1_cmpOut            : std_logic;
  SIGNAL ctr1                             : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL Add2_out1_demux1                 : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL yreg_1                           : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL Add2_out1_serial                 : vector_of_signed25(0 TO 1);  -- sfix25_En23 [2]
  SIGNAL Add2_out1_serial_bypass          : vector_of_signed25(0 TO 1);  -- sfix25_En23 [2]
  SIGNAL Add2_out1_serial_last_value      : vector_of_signed25(0 TO 1);  -- sfix25_En23 [2]
  SIGNAL ratechange_splitcomp_out0_2      : signed(49 DOWNTO 0);  -- sfix50_En47
  SIGNAL ratechange_splitcomp_out1_2      : signed(49 DOWNTO 0);  -- sfix50_En47
  SIGNAL compute_statistics_out2_unbuffer : signed(49 DOWNTO 0);  -- sfix50_En47
  SIGNAL variance                         : signed(26 DOWNTO 0);  -- sfix27_En24
  SIGNAL in2_unsigned                     : unsigned(15 DOWNTO 0);  -- ufix16_En15
  SIGNAL Add_add_cast                     : signed(27 DOWNTO 0);  -- sfix28_En24
  SIGNAL Add_add_cast_1                   : signed(27 DOWNTO 0);  -- sfix28_En24
  SIGNAL Add_out1                         : signed(27 DOWNTO 0);  -- sfix28_En24
  SIGNAL Data_Type_Conversion3_out1       : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL ctr_1_sig_eq_0_cmpOut_1          : std_logic;
  SIGNAL ctr0_1                           : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL Data_Type_Conversion3_out1_demux0 : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL yreg_0_1                         : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL ctr_1_sig_eq_1_cmpOut_1          : std_logic;
  SIGNAL ctr1_1                           : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL Data_Type_Conversion3_out1_demux1 : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL yreg_1_1                         : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Data_Type_Conversion3_out1_serial : vector_of_signed24(0 TO 1);  -- sfix24_En20 [2]
  SIGNAL Data_Type_Conversion3_out1_serial_bypass : vector_of_signed24(0 TO 1);  -- sfix24_En20 [2]
  SIGNAL Data_Type_Conversion3_out1_serial_last_value : vector_of_signed24(0 TO 1);  -- sfix24_En20 [2]
  SIGNAL ctr_1_sig_eq_0_cmpOut_2          : std_logic;
  SIGNAL ctr0_2                           : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL variance_demux0                  : signed(26 DOWNTO 0);  -- sfix27_En24
  SIGNAL yreg_0_2                         : signed(26 DOWNTO 0);  -- sfix27_En24
  SIGNAL ctr_1_sig_eq_1_cmpOut_2          : std_logic;
  SIGNAL ctr1_2                           : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL variance_demux1                  : signed(26 DOWNTO 0);  -- sfix27_En24
  SIGNAL yreg_1_2                         : signed(26 DOWNTO 0);  -- sfix27_En24
  SIGNAL variance_serial                  : vector_of_signed27(0 TO 1);  -- sfix27_En24 [2]
  SIGNAL variance_serial_bypass           : vector_of_signed27(0 TO 1);  -- sfix27_En24 [2]
  SIGNAL variance_serial_last_value       : vector_of_signed27(0 TO 1);  -- sfix27_En24 [2]

BEGIN
  in0_signed <= in0;

  in1_signed <= in1;

  in3_signed <= in3;

  enb_gated <= globalSchedule AND enb;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1
  Add2_out1_ctr_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      ctr_1_sig <= to_unsigned(16#00#, 8);
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        IF ctr_1_sig >= to_unsigned(16#01#, 8) THEN 
          ctr_1_sig <= to_unsigned(16#00#, 8);
        ELSE 
          ctr_1_sig <= ctr_1_sig + to_unsigned(16#01#, 8);
        END IF;
      END IF;
    END IF;
  END PROCESS Add2_out1_ctr_process;


  ratechange_splitcomp_out0 <= signed(in0_signed(0));

  ratechange_splitcomp_out1 <= signed(in0_signed(1));

  
  Sink_Data_unbuffer <= ratechange_splitcomp_out0 WHEN ctr_1_sig = to_unsigned(16#00#, 8) ELSE
      ratechange_splitcomp_out1;

  ratechange_splitcomp_out0_1 <= signed(in1_signed(0));

  ratechange_splitcomp_out1_1 <= signed(in1_signed(1));

  
  mean_unbuffer <= ratechange_splitcomp_out0_1 WHEN ctr_1_sig = to_unsigned(16#00#, 8) ELSE
      ratechange_splitcomp_out1_1;

  Add2_sub_cast <= resize(Sink_Data_unbuffer, 25);
  Add2_sub_cast_1 <= resize(mean_unbuffer, 25);
  Add2_out1 <= Add2_sub_cast - Add2_sub_cast_1;

  
  ctr_1_sig_eq_0_cmpOut <= '1' WHEN ctr_1_sig = to_unsigned(16#00#, 8) ELSE
      '0';

  ctr0 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & ctr_1_sig_eq_0_cmpOut;

  hwdemux_reg0_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      yreg_0 <= to_signed(16#0000000#, 25);
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        yreg_0 <= Add2_out1_demux0;
      END IF;
    END IF;
  END PROCESS hwdemux_reg0_process;


  
  Add2_out1_demux0 <= yreg_0 WHEN ctr0 = to_unsigned(16#00#, 8) ELSE
      Add2_out1;

  
  ctr_1_sig_eq_1_cmpOut <= '1' WHEN ctr_1_sig = to_unsigned(16#01#, 8) ELSE
      '0';

  ctr1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & ctr_1_sig_eq_1_cmpOut;

  hwdemux_reg1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      yreg_1 <= to_signed(16#0000000#, 25);
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        yreg_1 <= Add2_out1_demux1;
      END IF;
    END IF;
  END PROCESS hwdemux_reg1_process;


  
  Add2_out1_demux1 <= yreg_1 WHEN ctr1 = to_unsigned(16#00#, 8) ELSE
      Add2_out1;

  Add2_out1_serial(0) <= Add2_out1_demux0;
  Add2_out1_serial(1) <= Add2_out1_demux1;

  out0_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Add2_out1_serial_last_value(0) <= to_signed(16#0000000#, 25);
      Add2_out1_serial_last_value(1) <= to_signed(16#0000000#, 25);
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        Add2_out1_serial_last_value(0) <= Add2_out1_serial_bypass(0);
        Add2_out1_serial_last_value(1) <= Add2_out1_serial_bypass(1);
      END IF;
    END IF;
  END PROCESS out0_bypass_process;


  
  Add2_out1_serial_bypass(0) <= Add2_out1_serial_last_value(0) WHEN globalSchedule = '0' ELSE
      Add2_out1_serial(0);
  
  Add2_out1_serial_bypass(1) <= Add2_out1_serial_last_value(1) WHEN globalSchedule = '0' ELSE
      Add2_out1_serial(1);

  outputgen2: FOR k IN 0 TO 1 GENERATE
    out0(k) <= std_logic_vector(Add2_out1_serial_bypass(k));
  END GENERATE;

  ratechange_splitcomp_out0_2 <= signed(in3_signed(0));

  ratechange_splitcomp_out1_2 <= signed(in3_signed(1));

  
  compute_statistics_out2_unbuffer <= ratechange_splitcomp_out0_2 WHEN ctr_1_sig = to_unsigned(16#00#, 8) ELSE
      ratechange_splitcomp_out1_2;

  variance <= compute_statistics_out2_unbuffer(49 DOWNTO 23);

  in2_unsigned <= unsigned(in2);

  Add_add_cast <= resize(variance, 28);
  Add_add_cast_1 <= signed(resize(in2_unsigned & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 28));
  Add_out1 <= Add_add_cast + Add_add_cast_1;

  Data_Type_Conversion3_out1 <= Add_out1(27 DOWNTO 4);

  
  ctr_1_sig_eq_0_cmpOut_1 <= '1' WHEN ctr_1_sig = to_unsigned(16#00#, 8) ELSE
      '0';

  ctr0_1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & ctr_1_sig_eq_0_cmpOut_1;

  hwdemux_reg0_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      yreg_0_1 <= to_signed(16#000000#, 24);
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        yreg_0_1 <= Data_Type_Conversion3_out1_demux0;
      END IF;
    END IF;
  END PROCESS hwdemux_reg0_1_process;


  
  Data_Type_Conversion3_out1_demux0 <= yreg_0_1 WHEN ctr0_1 = to_unsigned(16#00#, 8) ELSE
      Data_Type_Conversion3_out1;

  
  ctr_1_sig_eq_1_cmpOut_1 <= '1' WHEN ctr_1_sig = to_unsigned(16#01#, 8) ELSE
      '0';

  ctr1_1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & ctr_1_sig_eq_1_cmpOut_1;

  hwdemux_reg1_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      yreg_1_1 <= to_signed(16#000000#, 24);
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        yreg_1_1 <= Data_Type_Conversion3_out1_demux1;
      END IF;
    END IF;
  END PROCESS hwdemux_reg1_1_process;


  
  Data_Type_Conversion3_out1_demux1 <= yreg_1_1 WHEN ctr1_1 = to_unsigned(16#00#, 8) ELSE
      Data_Type_Conversion3_out1;

  Data_Type_Conversion3_out1_serial(0) <= Data_Type_Conversion3_out1_demux0;
  Data_Type_Conversion3_out1_serial(1) <= Data_Type_Conversion3_out1_demux1;

  out1_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Data_Type_Conversion3_out1_serial_last_value(0) <= to_signed(16#000000#, 24);
      Data_Type_Conversion3_out1_serial_last_value(1) <= to_signed(16#000000#, 24);
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        Data_Type_Conversion3_out1_serial_last_value(0) <= Data_Type_Conversion3_out1_serial_bypass(0);
        Data_Type_Conversion3_out1_serial_last_value(1) <= Data_Type_Conversion3_out1_serial_bypass(1);
      END IF;
    END IF;
  END PROCESS out1_bypass_process;


  
  Data_Type_Conversion3_out1_serial_bypass(0) <= Data_Type_Conversion3_out1_serial_last_value(0) WHEN globalSchedule = '0' ELSE
      Data_Type_Conversion3_out1_serial(0);
  
  Data_Type_Conversion3_out1_serial_bypass(1) <= Data_Type_Conversion3_out1_serial_last_value(1) WHEN globalSchedule = '0' ELSE
      Data_Type_Conversion3_out1_serial(1);

  outputgen1: FOR k IN 0 TO 1 GENERATE
    out1(k) <= std_logic_vector(Data_Type_Conversion3_out1_serial_bypass(k));
  END GENERATE;

  
  ctr_1_sig_eq_0_cmpOut_2 <= '1' WHEN ctr_1_sig = to_unsigned(16#00#, 8) ELSE
      '0';

  ctr0_2 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & ctr_1_sig_eq_0_cmpOut_2;

  hwdemux_reg0_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      yreg_0_2 <= to_signed(16#0000000#, 27);
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        yreg_0_2 <= variance_demux0;
      END IF;
    END IF;
  END PROCESS hwdemux_reg0_2_process;


  
  variance_demux0 <= yreg_0_2 WHEN ctr0_2 = to_unsigned(16#00#, 8) ELSE
      variance;

  
  ctr_1_sig_eq_1_cmpOut_2 <= '1' WHEN ctr_1_sig = to_unsigned(16#01#, 8) ELSE
      '0';

  ctr1_2 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & ctr_1_sig_eq_1_cmpOut_2;

  hwdemux_reg1_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      yreg_1_2 <= to_signed(16#0000000#, 27);
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        yreg_1_2 <= variance_demux1;
      END IF;
    END IF;
  END PROCESS hwdemux_reg1_2_process;


  
  variance_demux1 <= yreg_1_2 WHEN ctr1_2 = to_unsigned(16#00#, 8) ELSE
      variance;

  variance_serial(0) <= variance_demux0;
  variance_serial(1) <= variance_demux1;

  out2_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      variance_serial_last_value(0) <= to_signed(16#0000000#, 27);
      variance_serial_last_value(1) <= to_signed(16#0000000#, 27);
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        variance_serial_last_value(0) <= variance_serial_bypass(0);
        variance_serial_last_value(1) <= variance_serial_bypass(1);
      END IF;
    END IF;
  END PROCESS out2_bypass_process;


  
  variance_serial_bypass(0) <= variance_serial_last_value(0) WHEN globalSchedule = '0' ELSE
      variance_serial(0);
  
  variance_serial_bypass(1) <= variance_serial_last_value(1) WHEN globalSchedule = '0' ELSE
      variance_serial(1);

  outputgen: FOR k IN 0 TO 1 GENERATE
    out2(k) <= std_logic_vector(variance_serial_bypass(k));
  END GENERATE;

END rtl;

