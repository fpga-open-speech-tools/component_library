-- -------------------------------------------------------------
-- 
-- File Name: C:\Users\wickh\Documents\NIH\simulink_models\models\noise_suppression\hdlsrc\noise_suppression\noise_suppression_streaming_partition_streamed_block.vhd
-- 
-- Generated by MATLAB 9.7 and HDL Coder 3.15
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: noise_suppression_streaming_partition_streamed_block
-- Source Path: 
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.noise_suppression_dataplane_pkg.ALL;

ENTITY noise_suppression_streaming_partition_streamed_block IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        in0                               :   IN    std_logic;
        in1                               :   IN    vector_of_std_logic_vector24(0 TO 1);  -- sfix24_En23 [2]
        in2                               :   IN    vector_of_std_logic_vector27(0 TO 1);  -- sfix27_En24 [2]
        in3                               :   IN    vector_of_std_logic_vector24(0 TO 1);  -- sfix24_En2 [2]
        in4                               :   IN    vector_of_std_logic_vector24(0 TO 1);  -- sfix24_En23 [2]
        in5                               :   IN    vector_of_std_logic_vector25(0 TO 1);  -- sfix25_En23 [2]
        enb_counter                       :   IN    std_logic_vector(15 DOWNTO 0);  -- ufix16
        globalSchedule                    :   IN    std_logic;
        out0                              :   OUT   vector_of_std_logic_vector50(0 TO 1)  -- sfix50_En46 [2]
        );
END noise_suppression_streaming_partition_streamed_block;


ARCHITECTURE rtl OF noise_suppression_streaming_partition_streamed_block IS

  ATTRIBUTE multstyle : string;

  ATTRIBUTE multstyle OF rtl : ARCHITECTURE IS "dsp";

  -- Signals
  SIGNAL enb_gated                        : std_logic;
  SIGNAL in1_signed                       : vector_of_std_logic_vector24(0 TO 1);  -- ufix24 [2]
  SIGNAL in2_signed                       : vector_of_std_logic_vector27(0 TO 1);  -- ufix27 [2]
  SIGNAL in3_signed                       : vector_of_std_logic_vector24(0 TO 1);  -- ufix24 [2]
  SIGNAL in4_signed                       : vector_of_std_logic_vector24(0 TO 1);  -- ufix24 [2]
  SIGNAL in5_signed                       : vector_of_std_logic_vector25(0 TO 1);  -- ufix25 [2]
  SIGNAL enb_counter_unsigned             : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL enb_counter_ge_30_1              : std_logic;
  SIGNAL enb_counter_le_31_1              : std_logic;
  SIGNAL streaming_partition_streamed_enb_phase_30_1 : std_logic;
  SIGNAL ctr_1_sig                        : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL ratechange_splitcomp_out0        : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL ratechange_splitcomp_out1        : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Sink_Data_unbuffer               : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL delayMatch2_reg                  : std_logic_vector(0 TO 3);  -- ufix1 [4]
  SIGNAL delayMatch2_reg_next             : std_logic_vector(0 TO 3);  -- ufix1 [4]
  SIGNAL enable                           : std_logic;
  SIGNAL delayMatch3_reg                  : vector_of_signed24(0 TO 3);  -- sfix24 [4]
  SIGNAL delayMatch3_reg_next             : vector_of_signed24(0 TO 3);  -- sfix24_En23 [4]
  SIGNAL Sink_Data_unbuffer_1             : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Sink_Data_unbuffer_dtc           : signed(49 DOWNTO 0);  -- sfix50_En46
  SIGNAL ratechange_splitcomp_out0_1      : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL ratechange_splitcomp_out1_1      : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL Add2_out1_unbuffer               : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL HwModeRegister2_reg              : vector_of_signed25(0 TO 2);  -- sfix25 [3]
  SIGNAL HwModeRegister2_reg_next         : vector_of_signed25(0 TO 2);  -- sfix25_En23 [3]
  SIGNAL Add2_out1_unbuffer_1             : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL ratechange_splitcomp_out0_2      : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL ratechange_splitcomp_out1_2      : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL mean_unbuffer                    : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL ratechange_splitcomp_out0_3      : signed(26 DOWNTO 0);  -- sfix27_En24
  SIGNAL ratechange_splitcomp_out1_3      : signed(26 DOWNTO 0);  -- sfix27_En24
  SIGNAL variance_unbuffer                : signed(26 DOWNTO 0);  -- sfix27_En24
  SIGNAL variance_unbuffer_1              : signed(26 DOWNTO 0);  -- sfix27_En24
  SIGNAL ratechange_splitcomp_out0_4      : signed(23 DOWNTO 0);  -- sfix24_En2
  SIGNAL ratechange_splitcomp_out1_4      : signed(23 DOWNTO 0);  -- sfix24_En2
  SIGNAL Mux_out1_unbuffer                : signed(23 DOWNTO 0);  -- sfix24_En2
  SIGNAL Mux_out1_unbuffer_1              : signed(23 DOWNTO 0);  -- sfix24_En2
  SIGNAL Product_out1                     : signed(50 DOWNTO 0);  -- sfix51_En26
  SIGNAL delayMatch_reg                   : vector_of_signed24(0 TO 1);  -- sfix24 [2]
  SIGNAL delayMatch_reg_next              : vector_of_signed24(0 TO 1);  -- sfix24_En23 [2]
  SIGNAL mean_unbuffer_1                  : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Product_out1_1                   : signed(50 DOWNTO 0);  -- sfix51_En26
  SIGNAL Data_Type_Conversion_out1        : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Add1_add_cast                    : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL Add1_add_cast_1                  : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL Add1_out1                        : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL Add1_out1_1                      : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL Product1_out1                    : signed(49 DOWNTO 0);  -- sfix50_En46
  SIGNAL ctr_1_sig_1                      : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL Product1_out1_1                  : signed(49 DOWNTO 0);  -- sfix50_En46
  SIGNAL Switch_out1                      : signed(49 DOWNTO 0);  -- sfix50_En46
  SIGNAL delayMatch4_reg                  : vector_of_unsigned8(0 TO 3);  -- ufix8 [4]
  SIGNAL delayMatch4_reg_next             : vector_of_unsigned8(0 TO 3);  -- ufix8 [4]
  SIGNAL ctr_1_sig_2                      : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL ctr_1_sig_eq_0_cmpOut            : std_logic;
  SIGNAL ctr0                             : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL Switch_out1_demux0               : signed(49 DOWNTO 0);  -- sfix50_En46
  SIGNAL yreg_0                           : signed(49 DOWNTO 0);  -- sfix50_En46
  SIGNAL ctr_1_sig_eq_1_cmpOut            : std_logic;
  SIGNAL ctr1                             : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL Switch_out1_demux1               : signed(49 DOWNTO 0);  -- sfix50_En46
  SIGNAL yreg_1                           : signed(49 DOWNTO 0);  -- sfix50_En46
  SIGNAL Switch_out1_serial               : vector_of_signed50(0 TO 1);  -- sfix50_En46 [2]
  SIGNAL Switch_out1_serial_hold          : vector_of_signed50(0 TO 1);  -- sfix50_En46 [2]

BEGIN
  in1_signed <= in1;

  in2_signed <= in2;

  in3_signed <= in3;

  in4_signed <= in4;

  in5_signed <= in5;

  enb_gated <= globalSchedule AND enb;

  enb_counter_unsigned <= unsigned(enb_counter);

  
  enb_counter_ge_30_1 <= '1' WHEN enb_counter_unsigned >= to_unsigned(16#001E#, 16) ELSE
      '0';

  
  enb_counter_le_31_1 <= '1' WHEN enb_counter_unsigned <= to_unsigned(16#001F#, 16) ELSE
      '0';

  streaming_partition_streamed_enb_phase_30_1 <= enb_counter_ge_30_1 AND enb_counter_le_31_1;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1
  ctr_0_11_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      ctr_1_sig <= to_unsigned(16#00#, 8);
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        IF streaming_partition_streamed_enb_phase_30_1 = '1' THEN 
          IF ctr_1_sig >= to_unsigned(16#01#, 8) THEN 
            ctr_1_sig <= to_unsigned(16#00#, 8);
          ELSE 
            ctr_1_sig <= ctr_1_sig + to_unsigned(16#01#, 8);
          END IF;
        END IF;
      END IF;
    END IF;
  END PROCESS ctr_0_11_process;


  ratechange_splitcomp_out0 <= signed(in1_signed(0));

  ratechange_splitcomp_out1 <= signed(in1_signed(1));

  
  Sink_Data_unbuffer <= ratechange_splitcomp_out0 WHEN ctr_1_sig = to_unsigned(16#00#, 8) ELSE
      ratechange_splitcomp_out1;

  delayMatch2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch2_reg(0) <= '0';
      delayMatch2_reg(1) <= '0';
      delayMatch2_reg(2) <= '0';
      delayMatch2_reg(3) <= '0';
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        delayMatch2_reg(0) <= delayMatch2_reg_next(0);
        delayMatch2_reg(1) <= delayMatch2_reg_next(1);
        delayMatch2_reg(2) <= delayMatch2_reg_next(2);
        delayMatch2_reg(3) <= delayMatch2_reg_next(3);
      END IF;
    END IF;
  END PROCESS delayMatch2_process;

  enable <= delayMatch2_reg(3);
  delayMatch2_reg_next(0) <= in0;
  delayMatch2_reg_next(1) <= delayMatch2_reg(0);
  delayMatch2_reg_next(2) <= delayMatch2_reg(1);
  delayMatch2_reg_next(3) <= delayMatch2_reg(2);

  delayMatch3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch3_reg(0) <= to_signed(16#000000#, 24);
      delayMatch3_reg(1) <= to_signed(16#000000#, 24);
      delayMatch3_reg(2) <= to_signed(16#000000#, 24);
      delayMatch3_reg(3) <= to_signed(16#000000#, 24);
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        delayMatch3_reg(0) <= delayMatch3_reg_next(0);
        delayMatch3_reg(1) <= delayMatch3_reg_next(1);
        delayMatch3_reg(2) <= delayMatch3_reg_next(2);
        delayMatch3_reg(3) <= delayMatch3_reg_next(3);
      END IF;
    END IF;
  END PROCESS delayMatch3_process;

  Sink_Data_unbuffer_1 <= delayMatch3_reg(3);
  delayMatch3_reg_next(0) <= Sink_Data_unbuffer;
  delayMatch3_reg_next(1) <= delayMatch3_reg(0);
  delayMatch3_reg_next(2) <= delayMatch3_reg(1);
  delayMatch3_reg_next(3) <= delayMatch3_reg(2);

  Sink_Data_unbuffer_dtc <= resize(Sink_Data_unbuffer_1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 50);

  ratechange_splitcomp_out0_1 <= signed(in5_signed(0));

  ratechange_splitcomp_out1_1 <= signed(in5_signed(1));

  
  Add2_out1_unbuffer <= ratechange_splitcomp_out0_1 WHEN ctr_1_sig = to_unsigned(16#00#, 8) ELSE
      ratechange_splitcomp_out1_1;

  HwModeRegister2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      HwModeRegister2_reg(0) <= to_signed(16#0000000#, 25);
      HwModeRegister2_reg(1) <= to_signed(16#0000000#, 25);
      HwModeRegister2_reg(2) <= to_signed(16#0000000#, 25);
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        HwModeRegister2_reg(0) <= HwModeRegister2_reg_next(0);
        HwModeRegister2_reg(1) <= HwModeRegister2_reg_next(1);
        HwModeRegister2_reg(2) <= HwModeRegister2_reg_next(2);
      END IF;
    END IF;
  END PROCESS HwModeRegister2_process;

  Add2_out1_unbuffer_1 <= HwModeRegister2_reg(2);
  HwModeRegister2_reg_next(0) <= Add2_out1_unbuffer;
  HwModeRegister2_reg_next(1) <= HwModeRegister2_reg(0);
  HwModeRegister2_reg_next(2) <= HwModeRegister2_reg(1);

  ratechange_splitcomp_out0_2 <= signed(in4_signed(0));

  ratechange_splitcomp_out1_2 <= signed(in4_signed(1));

  
  mean_unbuffer <= ratechange_splitcomp_out0_2 WHEN ctr_1_sig = to_unsigned(16#00#, 8) ELSE
      ratechange_splitcomp_out1_2;

  ratechange_splitcomp_out0_3 <= signed(in2_signed(0));

  ratechange_splitcomp_out1_3 <= signed(in2_signed(1));

  
  variance_unbuffer <= ratechange_splitcomp_out0_3 WHEN ctr_1_sig = to_unsigned(16#00#, 8) ELSE
      ratechange_splitcomp_out1_3;

  HwModeRegister_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      variance_unbuffer_1 <= to_signed(16#0000000#, 27);
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        variance_unbuffer_1 <= variance_unbuffer;
      END IF;
    END IF;
  END PROCESS HwModeRegister_process;


  ratechange_splitcomp_out0_4 <= signed(in3_signed(0));

  ratechange_splitcomp_out1_4 <= signed(in3_signed(1));

  
  Mux_out1_unbuffer <= ratechange_splitcomp_out0_4 WHEN ctr_1_sig = to_unsigned(16#00#, 8) ELSE
      ratechange_splitcomp_out1_4;

  HwModeRegister1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Mux_out1_unbuffer_1 <= to_signed(16#000000#, 24);
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        Mux_out1_unbuffer_1 <= Mux_out1_unbuffer;
      END IF;
    END IF;
  END PROCESS HwModeRegister1_process;


  Product_out1 <= variance_unbuffer_1 * Mux_out1_unbuffer_1;

  delayMatch_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_reg(0) <= to_signed(16#000000#, 24);
      delayMatch_reg(1) <= to_signed(16#000000#, 24);
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        delayMatch_reg(0) <= delayMatch_reg_next(0);
        delayMatch_reg(1) <= delayMatch_reg_next(1);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  mean_unbuffer_1 <= delayMatch_reg(1);
  delayMatch_reg_next(0) <= mean_unbuffer;
  delayMatch_reg_next(1) <= delayMatch_reg(0);

  PipelineRegister_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Product_out1_1 <= to_signed(0, 51);
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        Product_out1_1 <= Product_out1;
      END IF;
    END IF;
  END PROCESS PipelineRegister_process;


  Data_Type_Conversion_out1 <= Product_out1_1(26 DOWNTO 3);

  Add1_add_cast <= resize(mean_unbuffer_1, 25);
  Add1_add_cast_1 <= resize(Data_Type_Conversion_out1, 25);
  Add1_out1 <= Add1_add_cast + Add1_add_cast_1;

  HwModeRegister3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Add1_out1_1 <= to_signed(16#0000000#, 25);
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        Add1_out1_1 <= Add1_out1;
      END IF;
    END IF;
  END PROCESS HwModeRegister3_process;


  Product1_out1 <= Add2_out1_unbuffer_1 * Add1_out1_1;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1
  ctr_0_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      ctr_1_sig_1 <= to_unsigned(16#00#, 8);
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        IF streaming_partition_streamed_enb_phase_30_1 = '1' THEN 
          IF ctr_1_sig_1 >= to_unsigned(16#01#, 8) THEN 
            ctr_1_sig_1 <= to_unsigned(16#00#, 8);
          ELSE 
            ctr_1_sig_1 <= ctr_1_sig_1 + to_unsigned(16#01#, 8);
          END IF;
        END IF;
      END IF;
    END IF;
  END PROCESS ctr_0_1_process;


  PipelineRegister1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Product1_out1_1 <= to_signed(0, 50);
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        Product1_out1_1 <= Product1_out1;
      END IF;
    END IF;
  END PROCESS PipelineRegister1_process;


  
  Switch_out1 <= Sink_Data_unbuffer_dtc WHEN enable = '0' ELSE
      Product1_out1_1;

  delayMatch4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch4_reg(0) <= to_unsigned(16#00#, 8);
      delayMatch4_reg(1) <= to_unsigned(16#00#, 8);
      delayMatch4_reg(2) <= to_unsigned(16#00#, 8);
      delayMatch4_reg(3) <= to_unsigned(16#00#, 8);
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        delayMatch4_reg(0) <= delayMatch4_reg_next(0);
        delayMatch4_reg(1) <= delayMatch4_reg_next(1);
        delayMatch4_reg(2) <= delayMatch4_reg_next(2);
        delayMatch4_reg(3) <= delayMatch4_reg_next(3);
      END IF;
    END IF;
  END PROCESS delayMatch4_process;

  ctr_1_sig_2 <= delayMatch4_reg(3);
  delayMatch4_reg_next(0) <= ctr_1_sig_1;
  delayMatch4_reg_next(1) <= delayMatch4_reg(0);
  delayMatch4_reg_next(2) <= delayMatch4_reg(1);
  delayMatch4_reg_next(3) <= delayMatch4_reg(2);

  
  ctr_1_sig_eq_0_cmpOut <= '1' WHEN ctr_1_sig_2 = to_unsigned(16#00#, 8) ELSE
      '0';

  ctr0 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & ctr_1_sig_eq_0_cmpOut;

  hwdemux_reg0_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      yreg_0 <= to_signed(0, 50);
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        yreg_0 <= Switch_out1_demux0;
      END IF;
    END IF;
  END PROCESS hwdemux_reg0_process;


  
  Switch_out1_demux0 <= yreg_0 WHEN ctr0 = to_unsigned(16#00#, 8) ELSE
      Switch_out1;

  
  ctr_1_sig_eq_1_cmpOut <= '1' WHEN ctr_1_sig_2 = to_unsigned(16#01#, 8) ELSE
      '0';

  ctr1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & ctr_1_sig_eq_1_cmpOut;

  hwdemux_reg1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      yreg_1 <= to_signed(0, 50);
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        yreg_1 <= Switch_out1_demux1;
      END IF;
    END IF;
  END PROCESS hwdemux_reg1_process;


  
  Switch_out1_demux1 <= yreg_1 WHEN ctr1 = to_unsigned(16#00#, 8) ELSE
      Switch_out1;

  Switch_out1_serial(0) <= Switch_out1_demux0;
  Switch_out1_serial(1) <= Switch_out1_demux1;

  out0_hold_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Switch_out1_serial_hold(0) <= to_signed(0, 50);
      Switch_out1_serial_hold(1) <= to_signed(0, 50);
    ELSIF rising_edge(clk) THEN
      IF enb_gated = '1' THEN
        Switch_out1_serial_hold(0) <= Switch_out1_serial(0);
        Switch_out1_serial_hold(1) <= Switch_out1_serial(1);
      END IF;
    END IF;
  END PROCESS out0_hold_process;


  outputgen: FOR k IN 0 TO 1 GENERATE
    out0(k) <= std_logic_vector(Switch_out1_serial_hold(k));
  END GENERATE;

END rtl;

